#### 设计思路
1. 词法分析
词法分析可以直接分词，存在Token中，记录若干信息，包括类型，val（如果需要的话），Token本身即字符串。
2. 语法分析
语法分析可以直接用递归下降，最重要的是构建出语法分析树，存储形式为Node，这个表示语法分析树上面的一个节点，这个节点需要包括语法元素类型，例如if，while等等，指向其儿子节点的指针，这里有很多不同情况，比如if语句就要包括if(expr)state这样的三个部分。所以不同语句共用Node节点，空间换时间。
3. 符号表
符号应该在语法分析阶段就已经完成了，并且已经获得了他的类型和名称。但需要检查该符号是否出现在符号表。类C语言的符号表要考虑嵌套作用域问题，一个作用域（以花括号为区域）可能被嵌套在外层作用域中。所以要递归查找符号，不断地向外层查找，直到找到。可以使用栈来动态管理嵌套作用域，在完成分析后释放。为每一个过程建立一张符号表。并记录其最近外层的符号表指针。
符号表采用链表的形式，并且也无需提取出templist{temp，next}这样的结构形式，因为在C中可以用更紧凑的结构，直接将next纳入到temp类型中。
temp的offset可以使用一种简单的方式来计算，假设temp只定义和使用一次，那么，遍历每个四元式，如果遇到一次使用则offset-4，定义则offset+4，至于定义和使用的先后问题，可以考虑首先发生的是使用，其次发生的是定义。定义总是父亲节点，而使用是儿子节点。
考虑如下情况，由于后代节点必然先计算，所以，后代节点的作用域在代码序列上必然先于父亲节点。
所以可以看到，后代节点的作用域结束的地方就是父亲节点作用域开始的地方。所以，左边节点的作用域嵌套右边节点的作用域，父亲节点的作用域和左边节点的作用域并列。因此作用域不相交，可以使用这种简单的方法。


4. 语义分析和中间代码生成
这个时候需要考虑到生成四元式的问题，那么需要相应地定义四元式的结构体，Quad，相应地定义语法制导翻译的结构体保存一些语义信息，用以生成结构体。例如临时变量。
5. 目标代码生成
目标代码生成基于中间代码，即四元式，因此四元式中需要保存完整的目标代码生成的信息。特别是跳转的信息。

return生成思路：因为需要保存在eax中，所以需要将表达式的最终结果移动到eax中，所以首先判断表达式是否已经在eax中，如果没有，则需要将eax清空，然后将表达式移动或者加载到eax中
二元运算生成思路：为每个源操作数分配寄存器，如果有寄存器则不需要分配，没有则需要找一个空闲的寄存器。注意寄存器之间不要冲突
除法生成思路：首先清空eax和edx，然后将被除数放到eax中，加载除数，然后执行除法。
比较运算的生成思路：首先进行比较，然后清空eax方便放置结果。



应该要考虑将变量的生成全部移动到quadgen中，而prase中纯粹的是抽象语法树的分析。类型检查也应该在quadgen中完成。

赋值语句还需要进一步考虑，因为左侧可以不是变量，而是指针的解引用

## 重构心得
把四元式的参数转换为变量，而非抽象语法树节点，写的过程中会发现，使用抽象语法树节点其实是偷懒的结果，在中间代码生成这一步就应该要解决大部分代码逻辑生成，类型检查等等一系列的任务而最后一步目标代码生成则应该尽可能简单，仅仅起到与目标机器匹配的作用。
把临时变量，局部变量和常量整合成为一个类型，用不同type区分。也就是说，Var，广义地指向所有变量，常量在此需要理解为不可被用户修改的变量。所以准确说来，在程序设计过程中，所有的数据均称为变量。把他们统一在一起是至关重要的，因为他们虽然变量类型不同，但数据类型却可以相同。因此把他们拆开是极为麻烦的。这一点应该要洞见到。这就是数据结构的设计问题了。
还有就是，目标代码的生成又简化了很多，因为如果仅仅在寄存器中修改了变量而没有写回到内存中，这是极为麻烦的，必须要追踪其写入。而且，目前看起来，唯一能够修改内存的语句是赋值语句，其他语句均为临时变量的计算和控制逻辑。而在赋值语句的检查过程中，左边的值必须为一左值，左值在此应该被理解成为地址，往日我们对左值的理解不够清晰，将其理解成为非常量、非临时变量的东西。但事实证明，即使是临时变量（例如解引用）也是可以进行赋值的。所以左侧毋宁取出其地址，才是恰当的做法。