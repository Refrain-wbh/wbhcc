#### 设计思路
1. 词法分析
词法分析可以直接分词，存在Token中，记录若干信息，包括类型，val（如果需要的话），Token本身即字符串。
2. 语法分析
语法分析可以直接用递归下降，最重要的是构建出语法分析树，存储形式为Node，这个表示语法分析树上面的一个节点，这个节点需要包括语法元素类型，例如if，while等等，指向其儿子节点的指针，这里有很多不同情况，比如if语句就要包括if(expr)state这样的三个部分。所以不同语句共用Node节点，空间换时间。
3. 符号表
符号应该在语法分析阶段就已经完成了，并且已经获得了他的类型和名称。但需要检查该符号是否出现在符号表。类C语言的符号表要考虑嵌套作用域问题，一个作用域（以花括号为区域）可能被嵌套在外层作用域中。所以要递归查找符号，不断地向外层查找，直到找到。可以使用栈来动态管理嵌套作用域，在完成分析后释放。为每一个过程建立一张符号表。并记录其最近外层的符号表指针。
符号表采用链表的形式，并且也无需提取出templist{temp，next}这样的结构形式，因为在C中可以用更紧凑的结构，直接将next纳入到temp类型中。
temp的offset可以使用一种简单的方式来计算，假设temp只定义和使用一次，那么，遍历每个四元式，如果遇到一次使用则offset-4，定义则offset+4，至于定义和使用的先后问题，可以考虑首先发生的是使用，其次发生的是定义。定义总是父亲节点，而使用是儿子节点。
考虑如下情况，由于后代节点必然先计算，所以，后代节点的作用域在代码序列上必然先于父亲节点。
所以可以看到，后代节点的作用域结束的地方就是父亲节点作用域开始的地方。所以，左边节点的作用域嵌套右边节点的作用域，父亲节点的作用域和左边节点的作用域并列。因此作用域不相交，可以使用这种简单的方法。


4. 语义分析和中间代码生成
这个时候需要考虑到生成四元式的问题，那么需要相应地定义四元式的结构体，Quad，相应地定义语法制导翻译的结构体保存一些语义信息，用以生成结构体。例如临时变量。
5. 目标代码生成
目标代码生成基于中间代码，即四元式，因此四元式中需要保存完整的目标代码生成的信息。特别是跳转的信息。

return生成思路：因为需要保存在eax中，所以需要将表达式的最终结果移动到eax中，所以首先判断表达式是否已经在eax中，如果没有，则需要将eax清空，然后将表达式移动或者加载到eax中
二元运算生成思路：为每个源操作数分配寄存器，如果有寄存器则不需要分配，没有则需要找一个空闲的寄存器。注意寄存器之间不要冲突
除法生成思路：首先清空eax和edx，然后将被除数放到eax中，加载除数，然后执行除法。
比较运算的生成思路：首先进行比较，然后清空eax方便放置结果。



### todo
目前看起来，call function 
